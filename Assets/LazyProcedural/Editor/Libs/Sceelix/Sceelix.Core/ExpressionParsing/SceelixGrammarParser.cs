//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g 2017-01-23 16:45:03

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

#pragma warning disable 3021

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Sceelix.Designer.Graphs.ExpressionParsing
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class SceelixGrammarParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ATTRID", "BOOLEAN", "CHAR", "CHECK", "COLON", "COMMENT", "DIV", "DOT", "DOUBLE", "EQUALS", "ESC_SEQ", "EXPONENT", "FLOAT", "GT", "GTEQ", "HEX_DIGIT", "ID", "INT", "LOCAL", "LT", "LTEQ", "MINUS", "MOD", "MULT", "NOT", "NOTEQUALS", "OCTAL_ESC", "OR", "PLUS", "SPECIALID", "SQBRACKETCLOSE", "SQBRACKETOPEN", "STRING", "TYPE", "UNICODE_ESC", "WS", "'$'", "'('", "')'", "','", "'@'", "'@@'"
	};
	public const int EOF=-1;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int AND=4;
	public const int ATTRID=5;
	public const int BOOLEAN=6;
	public const int CHAR=7;
	public const int CHECK=8;
	public const int COLON=9;
	public const int COMMENT=10;
	public const int DIV=11;
	public const int DOT=12;
	public const int DOUBLE=13;
	public const int EQUALS=14;
	public const int ESC_SEQ=15;
	public const int EXPONENT=16;
	public const int FLOAT=17;
	public const int GT=18;
	public const int GTEQ=19;
	public const int HEX_DIGIT=20;
	public const int ID=21;
	public const int INT=22;
	public const int LOCAL=23;
	public const int LT=24;
	public const int LTEQ=25;
	public const int MINUS=26;
	public const int MOD=27;
	public const int MULT=28;
	public const int NOT=29;
	public const int NOTEQUALS=30;
	public const int OCTAL_ESC=31;
	public const int OR=32;
	public const int PLUS=33;
	public const int SPECIALID=34;
	public const int SQBRACKETCLOSE=35;
	public const int SQBRACKETOPEN=36;
	public const int STRING=37;
	public const int TYPE=38;
	public const int UNICODE_ESC=39;
	public const int WS=40;

	public SceelixGrammarParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SceelixGrammarParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return SceelixGrammarParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g"; } }


		public override void ReportError(RecognitionException e)
	    {
	        throw e;
	    }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:28:8: public expr : logicalExpression EOF !;
	[GrammarRule("expr")]
	public AstParserRuleReturnScope<CommonTree, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 1);
		TraceIn("expr", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EOF2_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(28, 25);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:29:2: ( logicalExpression EOF !)
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:29:4: logicalExpression EOF !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(29, 4);
			PushFollow(Follow._logicalExpression_in_expr85);
			logicalExpression1=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression1.Tree);
			DebugLocation(29, 25);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_expr87); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 1);
			LeaveRule("expr", 1);
			LeaveRule_expr();
		}
		DebugLocation(29, 25);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_logicalExpression();
	partial void LeaveRule_logicalExpression();

	// $ANTLR start "logicalExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:33:1: logicalExpression : booleanAndExpression ( OR ^ booleanAndExpression )* ;
	[GrammarRule("logicalExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalExpression()
	{
		EnterRule_logicalExpression();
		EnterRule("logicalExpression", 2);
		TraceIn("logicalExpression", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken OR4 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> booleanAndExpression3 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> booleanAndExpression5 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree OR4_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "logicalExpression");
		DebugLocation(33, 4);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:34:5: ( booleanAndExpression ( OR ^ booleanAndExpression )* )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:34:10: booleanAndExpression ( OR ^ booleanAndExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(34, 10);
			PushFollow(Follow._booleanAndExpression_in_logicalExpression107);
			booleanAndExpression3=booleanAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, booleanAndExpression3.Tree);
			DebugLocation(34, 31);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:34:31: ( OR ^ booleanAndExpression )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==OR))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:34:33: OR ^ booleanAndExpression
					{
					DebugLocation(34, 35);
					OR4=(IToken)Match(input,OR,Follow._OR_in_logicalExpression111); 
					OR4_tree = (CommonTree)adaptor.Create(OR4);
					root_0 = (CommonTree)adaptor.BecomeRoot(OR4_tree, root_0);
					DebugLocation(34, 37);
					PushFollow(Follow._booleanAndExpression_in_logicalExpression114);
					booleanAndExpression5=booleanAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, booleanAndExpression5.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalExpression", 2);
			LeaveRule("logicalExpression", 2);
			LeaveRule_logicalExpression();
		}
		DebugLocation(35, 4);
		} finally { DebugExitRule(GrammarFileName, "logicalExpression"); }
		return retval;

	}
	// $ANTLR end "logicalExpression"

	partial void EnterRule_booleanAndExpression();
	partial void LeaveRule_booleanAndExpression();

	// $ANTLR start "booleanAndExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:37:1: booleanAndExpression : equalityExpression ( AND ^ equalityExpression )* ;
	[GrammarRule("booleanAndExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> booleanAndExpression()
	{
		EnterRule_booleanAndExpression();
		EnterRule("booleanAndExpression", 3);
		TraceIn("booleanAndExpression", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken AND7 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpression6 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpression8 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree AND7_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "booleanAndExpression");
		DebugLocation(37, 4);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:38:5: ( equalityExpression ( AND ^ equalityExpression )* )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:38:10: equalityExpression ( AND ^ equalityExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(38, 10);
			PushFollow(Follow._equalityExpression_in_booleanAndExpression141);
			equalityExpression6=equalityExpression();
			PopFollow();

			adaptor.AddChild(root_0, equalityExpression6.Tree);
			DebugLocation(38, 29);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:38:29: ( AND ^ equalityExpression )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==AND))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:38:31: AND ^ equalityExpression
					{
					DebugLocation(38, 34);
					AND7=(IToken)Match(input,AND,Follow._AND_in_booleanAndExpression145); 
					AND7_tree = (CommonTree)adaptor.Create(AND7);
					root_0 = (CommonTree)adaptor.BecomeRoot(AND7_tree, root_0);
					DebugLocation(38, 36);
					PushFollow(Follow._equalityExpression_in_booleanAndExpression148);
					equalityExpression8=equalityExpression();
					PopFollow();

					adaptor.AddChild(root_0, equalityExpression8.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("booleanAndExpression", 3);
			LeaveRule("booleanAndExpression", 3);
			LeaveRule_booleanAndExpression();
		}
		DebugLocation(39, 4);
		} finally { DebugExitRule(GrammarFileName, "booleanAndExpression"); }
		return retval;

	}
	// $ANTLR end "booleanAndExpression"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();

	// $ANTLR start "equalityExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:41:1: equalityExpression : relationalExpression ( ( EQUALS ^| NOTEQUALS ^) relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 4);
		TraceIn("equalityExpression", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EQUALS10 = default(IToken);
		IToken NOTEQUALS11 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> relationalExpression9 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relationalExpression12 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EQUALS10_tree = default(CommonTree);
		CommonTree NOTEQUALS11_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(41, 4);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:42:5: ( relationalExpression ( ( EQUALS ^| NOTEQUALS ^) relationalExpression )* )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:42:10: relationalExpression ( ( EQUALS ^| NOTEQUALS ^) relationalExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(42, 10);
			PushFollow(Follow._relationalExpression_in_equalityExpression175);
			relationalExpression9=relationalExpression();
			PopFollow();

			adaptor.AddChild(root_0, relationalExpression9.Tree);
			DebugLocation(42, 31);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:42:31: ( ( EQUALS ^| NOTEQUALS ^) relationalExpression )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==EQUALS||LA4_0==NOTEQUALS))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:43:7: ( EQUALS ^| NOTEQUALS ^) relationalExpression
					{
					DebugLocation(43, 7);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:43:7: ( EQUALS ^| NOTEQUALS ^)
					int alt3=2;
					try { DebugEnterSubRule(3);
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if ((LA3_0==EQUALS))
					{
						alt3 = 1;
					}
					else if ((LA3_0==NOTEQUALS))
					{
						alt3 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:43:8: EQUALS ^
						{
						DebugLocation(43, 14);
						EQUALS10=(IToken)Match(input,EQUALS,Follow._EQUALS_in_equalityExpression187); 
						EQUALS10_tree = (CommonTree)adaptor.Create(EQUALS10);
						root_0 = (CommonTree)adaptor.BecomeRoot(EQUALS10_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:44:9: NOTEQUALS ^
						{
						DebugLocation(44, 18);
						NOTEQUALS11=(IToken)Match(input,NOTEQUALS,Follow._NOTEQUALS_in_equalityExpression199); 
						NOTEQUALS11_tree = (CommonTree)adaptor.Create(NOTEQUALS11);
						root_0 = (CommonTree)adaptor.BecomeRoot(NOTEQUALS11_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(3); }

					DebugLocation(44, 21);
					PushFollow(Follow._relationalExpression_in_equalityExpression203);
					relationalExpression12=relationalExpression();
					PopFollow();

					adaptor.AddChild(root_0, relationalExpression12.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 4);
			LeaveRule("equalityExpression", 4);
			LeaveRule_equalityExpression();
		}
		DebugLocation(45, 4);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();

	// $ANTLR start "relationalExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:47:1: relationalExpression : additiveExpression ( ( LT ^| LTEQ ^| GT ^| GTEQ ^) additiveExpression )* ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 5);
		TraceIn("relationalExpression", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LT14 = default(IToken);
		IToken LTEQ15 = default(IToken);
		IToken GT16 = default(IToken);
		IToken GTEQ17 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> additiveExpression13 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> additiveExpression18 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT14_tree = default(CommonTree);
		CommonTree LTEQ15_tree = default(CommonTree);
		CommonTree GT16_tree = default(CommonTree);
		CommonTree GTEQ17_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(47, 4);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:48:5: ( additiveExpression ( ( LT ^| LTEQ ^| GT ^| GTEQ ^) additiveExpression )* )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:48:10: additiveExpression ( ( LT ^| LTEQ ^| GT ^| GTEQ ^) additiveExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(48, 10);
			PushFollow(Follow._additiveExpression_in_relationalExpression229);
			additiveExpression13=additiveExpression();
			PopFollow();

			adaptor.AddChild(root_0, additiveExpression13.Tree);
			DebugLocation(48, 29);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:48:29: ( ( LT ^| LTEQ ^| GT ^| GTEQ ^) additiveExpression )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if (((LA6_0>=GT && LA6_0<=GTEQ)||(LA6_0>=LT && LA6_0<=LTEQ)))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:48:31: ( LT ^| LTEQ ^| GT ^| GTEQ ^) additiveExpression
					{
					DebugLocation(48, 31);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:48:31: ( LT ^| LTEQ ^| GT ^| GTEQ ^)
					int alt5=4;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					switch (input.LA(1))
					{
					case LT:
						{
						alt5 = 1;
						}
						break;
					case LTEQ:
						{
						alt5 = 2;
						}
						break;
					case GT:
						{
						alt5 = 3;
						}
						break;
					case GTEQ:
						{
						alt5 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:48:32: LT ^
						{
						DebugLocation(48, 34);
						LT14=(IToken)Match(input,LT,Follow._LT_in_relationalExpression234); 
						LT14_tree = (CommonTree)adaptor.Create(LT14);
						root_0 = (CommonTree)adaptor.BecomeRoot(LT14_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:49:11: LTEQ ^
						{
						DebugLocation(49, 15);
						LTEQ15=(IToken)Match(input,LTEQ,Follow._LTEQ_in_relationalExpression248); 
						LTEQ15_tree = (CommonTree)adaptor.Create(LTEQ15);
						root_0 = (CommonTree)adaptor.BecomeRoot(LTEQ15_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:50:11: GT ^
						{
						DebugLocation(50, 13);
						GT16=(IToken)Match(input,GT,Follow._GT_in_relationalExpression262); 
						GT16_tree = (CommonTree)adaptor.Create(GT16);
						root_0 = (CommonTree)adaptor.BecomeRoot(GT16_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:51:11: GTEQ ^
						{
						DebugLocation(51, 15);
						GTEQ17=(IToken)Match(input,GTEQ,Follow._GTEQ_in_relationalExpression276); 
						GTEQ17_tree = (CommonTree)adaptor.Create(GTEQ17);
						root_0 = (CommonTree)adaptor.BecomeRoot(GTEQ17_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(5); }

					DebugLocation(51, 18);
					PushFollow(Follow._additiveExpression_in_relationalExpression280);
					additiveExpression18=additiveExpression();
					PopFollow();

					adaptor.AddChild(root_0, additiveExpression18.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 5);
			LeaveRule("relationalExpression", 5);
			LeaveRule_relationalExpression();
		}
		DebugLocation(52, 4);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:54:1: additiveExpression : multiplicativeExpression ( ( PLUS ^| MINUS ^) multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 6);
		TraceIn("additiveExpression", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken PLUS20 = default(IToken);
		IToken MINUS21 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> multiplicativeExpression19 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multiplicativeExpression22 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PLUS20_tree = default(CommonTree);
		CommonTree MINUS21_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(54, 4);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:55:5: ( multiplicativeExpression ( ( PLUS ^| MINUS ^) multiplicativeExpression )* )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:55:10: multiplicativeExpression ( ( PLUS ^| MINUS ^) multiplicativeExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(55, 10);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression302);
			multiplicativeExpression19=multiplicativeExpression();
			PopFollow();

			adaptor.AddChild(root_0, multiplicativeExpression19.Tree);
			DebugLocation(56, 7);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:56:7: ( ( PLUS ^| MINUS ^) multiplicativeExpression )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==MINUS||LA8_0==PLUS))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:56:9: ( PLUS ^| MINUS ^) multiplicativeExpression
					{
					DebugLocation(56, 9);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:56:9: ( PLUS ^| MINUS ^)
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==PLUS))
					{
						alt7 = 1;
					}
					else if ((LA7_0==MINUS))
					{
						alt7 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:56:10: PLUS ^
						{
						DebugLocation(56, 14);
						PLUS20=(IToken)Match(input,PLUS,Follow._PLUS_in_additiveExpression314); 
						PLUS20_tree = (CommonTree)adaptor.Create(PLUS20);
						root_0 = (CommonTree)adaptor.BecomeRoot(PLUS20_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:57:9: MINUS ^
						{
						DebugLocation(57, 14);
						MINUS21=(IToken)Match(input,MINUS,Follow._MINUS_in_additiveExpression326); 
						MINUS21_tree = (CommonTree)adaptor.Create(MINUS21);
						root_0 = (CommonTree)adaptor.BecomeRoot(MINUS21_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(58, 7);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression338);
					multiplicativeExpression22=multiplicativeExpression();
					PopFollow();

					adaptor.AddChild(root_0, multiplicativeExpression22.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 6);
			LeaveRule("additiveExpression", 6);
			LeaveRule_additiveExpression();
		}
		DebugLocation(59, 4);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:61:1: multiplicativeExpression : unaryExpression ( ( MULT ^| DIV ^| MOD ^) unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 7);
		TraceIn("multiplicativeExpression", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken MULT24 = default(IToken);
		IToken DIV25 = default(IToken);
		IToken MOD26 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression27 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree MULT24_tree = default(CommonTree);
		CommonTree DIV25_tree = default(CommonTree);
		CommonTree MOD26_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(61, 4);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:62:5: ( unaryExpression ( ( MULT ^| DIV ^| MOD ^) unaryExpression )* )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:62:10: unaryExpression ( ( MULT ^| DIV ^| MOD ^) unaryExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(62, 10);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression361);
			unaryExpression23=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression23.Tree);
			DebugLocation(62, 26);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:62:26: ( ( MULT ^| DIV ^| MOD ^) unaryExpression )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==DIV||(LA10_0>=MOD && LA10_0<=MULT)))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:62:27: ( MULT ^| DIV ^| MOD ^) unaryExpression
					{
					DebugLocation(62, 27);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:62:27: ( MULT ^| DIV ^| MOD ^)
					int alt9=3;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					switch (input.LA(1))
					{
					case MULT:
						{
						alt9 = 1;
						}
						break;
					case DIV:
						{
						alt9 = 2;
						}
						break;
					case MOD:
						{
						alt9 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:62:29: MULT ^
						{
						DebugLocation(62, 33);
						MULT24=(IToken)Match(input,MULT,Follow._MULT_in_multiplicativeExpression366); 
						MULT24_tree = (CommonTree)adaptor.Create(MULT24);
						root_0 = (CommonTree)adaptor.BecomeRoot(MULT24_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:62:37: DIV ^
						{
						DebugLocation(62, 40);
						DIV25=(IToken)Match(input,DIV,Follow._DIV_in_multiplicativeExpression371); 
						DIV25_tree = (CommonTree)adaptor.Create(DIV25);
						root_0 = (CommonTree)adaptor.BecomeRoot(DIV25_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:62:44: MOD ^
						{
						DebugLocation(62, 47);
						MOD26=(IToken)Match(input,MOD,Follow._MOD_in_multiplicativeExpression376); 
						MOD26_tree = (CommonTree)adaptor.Create(MOD26);
						root_0 = (CommonTree)adaptor.BecomeRoot(MOD26_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(9); }

					DebugLocation(62, 51);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression381);
					unaryExpression27=unaryExpression();
					PopFollow();

					adaptor.AddChild(root_0, unaryExpression27.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 7);
			LeaveRule("multiplicativeExpression", 7);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(63, 4);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();

	// $ANTLR start "unaryExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:65:1: unaryExpression : ( NOT ^| MINUS ^)? arrayExpression ;
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 8);
		TraceIn("unaryExpression", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NOT28 = default(IToken);
		IToken MINUS29 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> arrayExpression30 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NOT28_tree = default(CommonTree);
		CommonTree MINUS29_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(65, 39);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:66:5: ( ( NOT ^| MINUS ^)? arrayExpression )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:66:10: ( NOT ^| MINUS ^)? arrayExpression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(66, 10);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:66:10: ( NOT ^| MINUS ^)?
			int alt11=3;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==NOT))
			{
				alt11 = 1;
			}
			else if ((LA11_0==MINUS))
			{
				alt11 = 2;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:66:11: NOT ^
				{
				DebugLocation(66, 14);
				NOT28=(IToken)Match(input,NOT,Follow._NOT_in_unaryExpression404); 
				NOT28_tree = (CommonTree)adaptor.Create(NOT28);
				root_0 = (CommonTree)adaptor.BecomeRoot(NOT28_tree, root_0);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:66:16: MINUS ^
				{
				DebugLocation(66, 21);
				MINUS29=(IToken)Match(input,MINUS,Follow._MINUS_in_unaryExpression407); 
				MINUS29_tree = (CommonTree)adaptor.Create(MINUS29);
				root_0 = (CommonTree)adaptor.BecomeRoot(MINUS29_tree, root_0);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(66, 25);
			PushFollow(Follow._arrayExpression_in_unaryExpression412);
			arrayExpression30=arrayExpression();
			PopFollow();

			adaptor.AddChild(root_0, arrayExpression30.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 8);
			LeaveRule("unaryExpression", 8);
			LeaveRule_unaryExpression();
		}
		DebugLocation(66, 39);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_arrayExpression();
	partial void LeaveRule_arrayExpression();

	// $ANTLR start "arrayExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:68:1: arrayExpression : primaryExpression ( SQBRACKETOPEN ^ logicalExpression SQBRACKETCLOSE )* ;
	[GrammarRule("arrayExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> arrayExpression()
	{
		EnterRule_arrayExpression();
		EnterRule("arrayExpression", 9);
		TraceIn("arrayExpression", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken SQBRACKETOPEN32 = default(IToken);
		IToken SQBRACKETCLOSE34 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primaryExpression31 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression33 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SQBRACKETOPEN32_tree = default(CommonTree);
		CommonTree SQBRACKETCLOSE34_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "arrayExpression");
		DebugLocation(68, 71);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:69:2: ( primaryExpression ( SQBRACKETOPEN ^ logicalExpression SQBRACKETCLOSE )* )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:69:4: primaryExpression ( SQBRACKETOPEN ^ logicalExpression SQBRACKETCLOSE )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(69, 4);
			PushFollow(Follow._primaryExpression_in_arrayExpression426);
			primaryExpression31=primaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, primaryExpression31.Tree);
			DebugLocation(69, 22);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:69:22: ( SQBRACKETOPEN ^ logicalExpression SQBRACKETCLOSE )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==SQBRACKETOPEN))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:69:23: SQBRACKETOPEN ^ logicalExpression SQBRACKETCLOSE
					{
					DebugLocation(69, 36);
					SQBRACKETOPEN32=(IToken)Match(input,SQBRACKETOPEN,Follow._SQBRACKETOPEN_in_arrayExpression429); 
					SQBRACKETOPEN32_tree = (CommonTree)adaptor.Create(SQBRACKETOPEN32);
					root_0 = (CommonTree)adaptor.BecomeRoot(SQBRACKETOPEN32_tree, root_0);
					DebugLocation(69, 38);
					PushFollow(Follow._logicalExpression_in_arrayExpression432);
					logicalExpression33=logicalExpression();
					PopFollow();

					adaptor.AddChild(root_0, logicalExpression33.Tree);
					DebugLocation(69, 56);
					SQBRACKETCLOSE34=(IToken)Match(input,SQBRACKETCLOSE,Follow._SQBRACKETCLOSE_in_arrayExpression434); 
					SQBRACKETCLOSE34_tree = (CommonTree)adaptor.Create(SQBRACKETCLOSE34);
					adaptor.AddChild(root_0, SQBRACKETCLOSE34_tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayExpression", 9);
			LeaveRule("arrayExpression", 9);
			LeaveRule_arrayExpression();
		}
		DebugLocation(69, 71);
		} finally { DebugExitRule(GrammarFileName, "arrayExpression"); }
		return retval;

	}
	// $ANTLR end "arrayExpression"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();

	// $ANTLR start "primaryExpression"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:74:1: primaryExpression : ( '(' logicalExpression ')' -> ^( TYPE[\"()\"] logicalExpression ) | value | parameter | attribute | internalattribute | ID ( '(' ( args )? ')' ) -> ^( TYPE[\"DirectFunction\"] ID ( args )? ) | array );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 10);
		TraceIn("primaryExpression", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal35 = default(IToken);
		IToken char_literal37 = default(IToken);
		IToken ID42 = default(IToken);
		IToken char_literal43 = default(IToken);
		IToken char_literal45 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> value38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> parameter39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> internalattribute41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> args44 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> array46 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal35_tree = default(CommonTree);
		CommonTree char_literal37_tree = default(CommonTree);
		CommonTree ID42_tree = default(CommonTree);
		CommonTree char_literal43_tree = default(CommonTree);
		CommonTree char_literal45_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args");
		RewriteRuleSubtreeStream stream_logicalExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalExpression");
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(74, 13);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:75:5: ( '(' logicalExpression ')' -> ^( TYPE[\"()\"] logicalExpression ) | value | parameter | attribute | internalattribute | ID ( '(' ( args )? ')' ) -> ^( TYPE[\"DirectFunction\"] ID ( args )? ) | array )
			int alt14=7;
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case 42:
				{
				alt14 = 1;
				}
				break;
			case BOOLEAN:
			case CHAR:
			case DOUBLE:
			case FLOAT:
			case INT:
			case STRING:
				{
				alt14 = 2;
				}
				break;
			case ID:
				{
				int LA14_3 = input.LA(2);

				if ((LA14_3==EOF||LA14_3==AND||LA14_3==COLON||LA14_3==DIV||LA14_3==EQUALS||(LA14_3>=GT && LA14_3<=GTEQ)||(LA14_3>=LT && LA14_3<=MULT)||LA14_3==NOTEQUALS||(LA14_3>=OR && LA14_3<=PLUS)||(LA14_3>=SQBRACKETCLOSE && LA14_3<=SQBRACKETOPEN)||(LA14_3>=43 && LA14_3<=44)))
				{
					alt14 = 3;
				}
				else if ((LA14_3==42))
				{
					alt14 = 6;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 14, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 45:
				{
				alt14 = 4;
				}
				break;
			case 46:
				{
				alt14 = 5;
				}
				break;
			case SQBRACKETOPEN:
				{
				alt14 = 7;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:76:5: '(' logicalExpression ')'
				{
				DebugLocation(76, 5);
				char_literal35=(IToken)Match(input,42,Follow._42_in_primaryExpression460);  
				stream_42.Add(char_literal35);

				DebugLocation(76, 9);
				PushFollow(Follow._logicalExpression_in_primaryExpression462);
				logicalExpression36=logicalExpression();
				PopFollow();

				stream_logicalExpression.Add(logicalExpression36.Tree);
				DebugLocation(76, 27);
				char_literal37=(IToken)Match(input,43,Follow._43_in_primaryExpression464);  
				stream_43.Add(char_literal37);



				{
				// AST REWRITE
				// elements: logicalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 76:31: -> ^( TYPE[\"()\"] logicalExpression )
				{
					DebugLocation(76, 34);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:76:34: ^( TYPE[\"()\"] logicalExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(76, 36);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "()"), root_1);

					DebugLocation(76, 47);
					adaptor.AddChild(root_1, stream_logicalExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:77:9: value
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(77, 9);
				PushFollow(Follow._value_in_primaryExpression483);
				value38=value();
				PopFollow();

				adaptor.AddChild(root_0, value38.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:78:7: parameter
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(78, 7);
				PushFollow(Follow._parameter_in_primaryExpression495);
				parameter39=parameter();
				PopFollow();

				adaptor.AddChild(root_0, parameter39.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:79:9: attribute
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(79, 9);
				PushFollow(Follow._attribute_in_primaryExpression505);
				attribute40=attribute();
				PopFollow();

				adaptor.AddChild(root_0, attribute40.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:80:7: internalattribute
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(80, 7);
				PushFollow(Follow._internalattribute_in_primaryExpression513);
				internalattribute41=internalattribute();
				PopFollow();

				adaptor.AddChild(root_0, internalattribute41.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:82:9: ID ( '(' ( args )? ')' )
				{
				DebugLocation(82, 9);
				ID42=(IToken)Match(input,ID,Follow._ID_in_primaryExpression528);  
				stream_ID.Add(ID42);

				DebugLocation(82, 12);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:82:12: ( '(' ( args )? ')' )
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:82:13: '(' ( args )? ')'
				{
				DebugLocation(82, 13);
				char_literal43=(IToken)Match(input,42,Follow._42_in_primaryExpression531);  
				stream_42.Add(char_literal43);

				DebugLocation(82, 17);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:82:17: ( args )?
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if (((LA13_0>=BOOLEAN && LA13_0<=CHAR)||LA13_0==DOUBLE||LA13_0==FLOAT||(LA13_0>=ID && LA13_0<=INT)||LA13_0==MINUS||LA13_0==NOT||(LA13_0>=SQBRACKETOPEN && LA13_0<=STRING)||LA13_0==42||(LA13_0>=45 && LA13_0<=46)))
				{
					alt13 = 1;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:82:17: args
					{
					DebugLocation(82, 17);
					PushFollow(Follow._args_in_primaryExpression533);
					args44=args();
					PopFollow();

					stream_args.Add(args44.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(13); }

				DebugLocation(82, 23);
				char_literal45=(IToken)Match(input,43,Follow._43_in_primaryExpression536);  
				stream_43.Add(char_literal45);


				}



				{
				// AST REWRITE
				// elements: args, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 82:28: -> ^( TYPE[\"DirectFunction\"] ID ( args )? )
				{
					DebugLocation(82, 31);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:82:31: ^( TYPE[\"DirectFunction\"] ID ( args )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(82, 33);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "DirectFunction"), root_1);

					DebugLocation(82, 56);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(82, 59);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:82:59: ( args )?
					if (stream_args.HasNext)
					{
						DebugLocation(82, 59);
						adaptor.AddChild(root_1, stream_args.NextTree());

					}
					stream_args.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:83:9: array
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(83, 9);
				PushFollow(Follow._array_in_primaryExpression559);
				array46=array();
				PopFollow();

				adaptor.AddChild(root_0, array46.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 10);
			LeaveRule("primaryExpression", 10);
			LeaveRule_primaryExpression();
		}
		DebugLocation(83, 13);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_array();
	partial void LeaveRule_array();

	// $ANTLR start "array"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:87:1: array : SQBRACKETOPEN ( arraykeyValues )? SQBRACKETCLOSE -> ^( TYPE[\"Array\"] ( arraykeyValues )? ) ;
	[GrammarRule("array")]
	private AstParserRuleReturnScope<CommonTree, IToken> array()
	{
		EnterRule_array();
		EnterRule("array", 11);
		TraceIn("array", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken SQBRACKETOPEN47 = default(IToken);
		IToken SQBRACKETCLOSE49 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> arraykeyValues48 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SQBRACKETOPEN47_tree = default(CommonTree);
		CommonTree SQBRACKETCLOSE49_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SQBRACKETCLOSE=new RewriteRuleITokenStream(adaptor,"token SQBRACKETCLOSE");
		RewriteRuleITokenStream stream_SQBRACKETOPEN=new RewriteRuleITokenStream(adaptor,"token SQBRACKETOPEN");
		RewriteRuleSubtreeStream stream_arraykeyValues=new RewriteRuleSubtreeStream(adaptor,"rule arraykeyValues");
		try { DebugEnterRule(GrammarFileName, "array");
		DebugLocation(87, 89);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:87:8: ( SQBRACKETOPEN ( arraykeyValues )? SQBRACKETCLOSE -> ^( TYPE[\"Array\"] ( arraykeyValues )? ) )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:87:10: SQBRACKETOPEN ( arraykeyValues )? SQBRACKETCLOSE
			{
			DebugLocation(87, 10);
			SQBRACKETOPEN47=(IToken)Match(input,SQBRACKETOPEN,Follow._SQBRACKETOPEN_in_array582);  
			stream_SQBRACKETOPEN.Add(SQBRACKETOPEN47);

			DebugLocation(87, 24);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:87:24: ( arraykeyValues )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if (((LA15_0>=BOOLEAN && LA15_0<=CHAR)||LA15_0==DOUBLE||LA15_0==FLOAT||(LA15_0>=ID && LA15_0<=INT)||LA15_0==MINUS||LA15_0==NOT||(LA15_0>=SQBRACKETOPEN && LA15_0<=STRING)||LA15_0==42||(LA15_0>=45 && LA15_0<=46)))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:87:24: arraykeyValues
				{
				DebugLocation(87, 24);
				PushFollow(Follow._arraykeyValues_in_array584);
				arraykeyValues48=arraykeyValues();
				PopFollow();

				stream_arraykeyValues.Add(arraykeyValues48.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(87, 40);
			SQBRACKETCLOSE49=(IToken)Match(input,SQBRACKETCLOSE,Follow._SQBRACKETCLOSE_in_array587);  
			stream_SQBRACKETCLOSE.Add(SQBRACKETCLOSE49);



			{
			// AST REWRITE
			// elements: arraykeyValues
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 87:55: -> ^( TYPE[\"Array\"] ( arraykeyValues )? )
			{
				DebugLocation(87, 58);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:87:58: ^( TYPE[\"Array\"] ( arraykeyValues )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(87, 60);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Array"), root_1);

				DebugLocation(87, 74);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:87:74: ( arraykeyValues )?
				if (stream_arraykeyValues.HasNext)
				{
					DebugLocation(87, 74);
					adaptor.AddChild(root_1, stream_arraykeyValues.NextTree());

				}
				stream_arraykeyValues.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array", 11);
			LeaveRule("array", 11);
			LeaveRule_array();
		}
		DebugLocation(87, 89);
		} finally { DebugExitRule(GrammarFileName, "array"); }
		return retval;

	}
	// $ANTLR end "array"

	partial void EnterRule_arraykeyValues();
	partial void LeaveRule_arraykeyValues();

	// $ANTLR start "arraykeyValues"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:90:1: arraykeyValues : keyvalue ( ',' keyvalue )* -> ^( TYPE[\"ArrayKeyValue\"] ( keyvalue )* ) ;
	[GrammarRule("arraykeyValues")]
	private AstParserRuleReturnScope<CommonTree, IToken> arraykeyValues()
	{
		EnterRule_arraykeyValues();
		EnterRule("arraykeyValues", 12);
		TraceIn("arraykeyValues", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal51 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> keyvalue50 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> keyvalue52 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal51_tree = default(CommonTree);
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleSubtreeStream stream_keyvalue=new RewriteRuleSubtreeStream(adaptor,"rule keyvalue");
		try { DebugEnterRule(GrammarFileName, "arraykeyValues");
		DebugLocation(90, 67);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:91:2: ( keyvalue ( ',' keyvalue )* -> ^( TYPE[\"ArrayKeyValue\"] ( keyvalue )* ) )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:91:5: keyvalue ( ',' keyvalue )*
			{
			DebugLocation(91, 5);
			PushFollow(Follow._keyvalue_in_arraykeyValues609);
			keyvalue50=keyvalue();
			PopFollow();

			stream_keyvalue.Add(keyvalue50.Tree);
			DebugLocation(91, 14);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:91:14: ( ',' keyvalue )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==44))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:91:15: ',' keyvalue
					{
					DebugLocation(91, 15);
					char_literal51=(IToken)Match(input,44,Follow._44_in_arraykeyValues612);  
					stream_44.Add(char_literal51);

					DebugLocation(91, 19);
					PushFollow(Follow._keyvalue_in_arraykeyValues614);
					keyvalue52=keyvalue();
					PopFollow();

					stream_keyvalue.Add(keyvalue52.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }



			{
			// AST REWRITE
			// elements: keyvalue
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 91:31: -> ^( TYPE[\"ArrayKeyValue\"] ( keyvalue )* )
			{
				DebugLocation(91, 34);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:91:34: ^( TYPE[\"ArrayKeyValue\"] ( keyvalue )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(91, 36);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "ArrayKeyValue"), root_1);

				DebugLocation(91, 58);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:91:58: ( keyvalue )*
				while ( stream_keyvalue.HasNext )
				{
					DebugLocation(91, 58);
					adaptor.AddChild(root_1, stream_keyvalue.NextTree());

				}
				stream_keyvalue.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arraykeyValues", 12);
			LeaveRule("arraykeyValues", 12);
			LeaveRule_arraykeyValues();
		}
		DebugLocation(91, 67);
		} finally { DebugExitRule(GrammarFileName, "arraykeyValues"); }
		return retval;

	}
	// $ANTLR end "arraykeyValues"

	partial void EnterRule_keyvalue();
	partial void LeaveRule_keyvalue();

	// $ANTLR start "keyvalue"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:94:1: keyvalue : logicalExpression ( COLON ^ logicalExpression )? ;
	[GrammarRule("keyvalue")]
	private AstParserRuleReturnScope<CommonTree, IToken> keyvalue()
	{
		EnterRule_keyvalue();
		EnterRule("keyvalue", 13);
		TraceIn("keyvalue", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COLON54 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression53 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression55 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON54_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "keyvalue");
		DebugLocation(94, 49);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:95:2: ( logicalExpression ( COLON ^ logicalExpression )? )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:95:4: logicalExpression ( COLON ^ logicalExpression )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(95, 4);
			PushFollow(Follow._logicalExpression_in_keyvalue639);
			logicalExpression53=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression53.Tree);
			DebugLocation(95, 22);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:95:22: ( COLON ^ logicalExpression )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==COLON))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:95:23: COLON ^ logicalExpression
				{
				DebugLocation(95, 28);
				COLON54=(IToken)Match(input,COLON,Follow._COLON_in_keyvalue642); 
				COLON54_tree = (CommonTree)adaptor.Create(COLON54);
				root_0 = (CommonTree)adaptor.BecomeRoot(COLON54_tree, root_0);
				DebugLocation(95, 30);
				PushFollow(Follow._logicalExpression_in_keyvalue645);
				logicalExpression55=logicalExpression();
				PopFollow();

				adaptor.AddChild(root_0, logicalExpression55.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("keyvalue", 13);
			LeaveRule("keyvalue", 13);
			LeaveRule_keyvalue();
		}
		DebugLocation(95, 49);
		} finally { DebugExitRule(GrammarFileName, "keyvalue"); }
		return retval;

	}
	// $ANTLR end "keyvalue"

	partial void EnterRule_className();
	partial void LeaveRule_className();

	// $ANTLR start "className"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:108:1: className : ID -> ^( TYPE[\"ClassName\"] ID ) ;
	[GrammarRule("className")]
	private AstParserRuleReturnScope<CommonTree, IToken> className()
	{
		EnterRule_className();
		EnterRule("className", 14);
		TraceIn("className", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID56 = default(IToken);

		CommonTree ID56_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "className");
		DebugLocation(108, 32);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:109:2: ( ID -> ^( TYPE[\"ClassName\"] ID ) )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:109:4: ID
			{
			DebugLocation(109, 4);
			ID56=(IToken)Match(input,ID,Follow._ID_in_className688);  
			stream_ID.Add(ID56);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 109:7: -> ^( TYPE[\"ClassName\"] ID )
			{
				DebugLocation(109, 10);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:109:10: ^( TYPE[\"ClassName\"] ID )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(109, 12);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "ClassName"), root_1);

				DebugLocation(109, 30);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("className", 14);
			LeaveRule("className", 14);
			LeaveRule_className();
		}
		DebugLocation(109, 32);
		} finally { DebugExitRule(GrammarFileName, "className"); }
		return retval;

	}
	// $ANTLR end "className"

	partial void EnterRule_propertyOrFunction();
	partial void LeaveRule_propertyOrFunction();

	// $ANTLR start "propertyOrFunction"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:111:1: propertyOrFunction : ( ID -> ^( TYPE[\"Property\"] ID ) | ID ( '(' ( args )? ')' ) -> ^( TYPE[\"Function\"] ID ( args )? ) );
	[GrammarRule("propertyOrFunction")]
	private AstParserRuleReturnScope<CommonTree, IToken> propertyOrFunction()
	{
		EnterRule_propertyOrFunction();
		EnterRule("propertyOrFunction", 15);
		TraceIn("propertyOrFunction", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID57 = default(IToken);
		IToken ID58 = default(IToken);
		IToken char_literal59 = default(IToken);
		IToken char_literal61 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> args60 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ID57_tree = default(CommonTree);
		CommonTree ID58_tree = default(CommonTree);
		CommonTree char_literal59_tree = default(CommonTree);
		CommonTree char_literal61_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args");
		try { DebugEnterRule(GrammarFileName, "propertyOrFunction");
		DebugLocation(111, 4);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:111:20: ( ID -> ^( TYPE[\"Property\"] ID ) | ID ( '(' ( args )? ')' ) -> ^( TYPE[\"Function\"] ID ( args )? ) )
			int alt19=2;
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==ID))
			{
				int LA19_1 = input.LA(2);

				if ((LA19_1==EOF))
				{
					alt19 = 1;
				}
				else if ((LA19_1==42))
				{
					alt19 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 19, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:111:24: ID
				{
				DebugLocation(111, 24);
				ID57=(IToken)Match(input,ID,Follow._ID_in_propertyOrFunction707);  
				stream_ID.Add(ID57);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 111:30: -> ^( TYPE[\"Property\"] ID )
				{
					DebugLocation(111, 33);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:111:33: ^( TYPE[\"Property\"] ID )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(111, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Property"), root_1);

					DebugLocation(111, 52);
					adaptor.AddChild(root_1, stream_ID.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:112:7: ID ( '(' ( args )? ')' )
				{
				DebugLocation(112, 7);
				ID58=(IToken)Match(input,ID,Follow._ID_in_propertyOrFunction728);  
				stream_ID.Add(ID58);

				DebugLocation(112, 10);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:112:10: ( '(' ( args )? ')' )
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:112:11: '(' ( args )? ')'
				{
				DebugLocation(112, 11);
				char_literal59=(IToken)Match(input,42,Follow._42_in_propertyOrFunction731);  
				stream_42.Add(char_literal59);

				DebugLocation(112, 15);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:112:15: ( args )?
				int alt18=2;
				try { DebugEnterSubRule(18);
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if (((LA18_0>=BOOLEAN && LA18_0<=CHAR)||LA18_0==DOUBLE||LA18_0==FLOAT||(LA18_0>=ID && LA18_0<=INT)||LA18_0==MINUS||LA18_0==NOT||(LA18_0>=SQBRACKETOPEN && LA18_0<=STRING)||LA18_0==42||(LA18_0>=45 && LA18_0<=46)))
				{
					alt18 = 1;
				}
				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:112:15: args
					{
					DebugLocation(112, 15);
					PushFollow(Follow._args_in_propertyOrFunction733);
					args60=args();
					PopFollow();

					stream_args.Add(args60.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(18); }

				DebugLocation(112, 21);
				char_literal61=(IToken)Match(input,43,Follow._43_in_propertyOrFunction736);  
				stream_43.Add(char_literal61);


				}



				{
				// AST REWRITE
				// elements: args, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 112:26: -> ^( TYPE[\"Function\"] ID ( args )? )
				{
					DebugLocation(112, 29);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:112:29: ^( TYPE[\"Function\"] ID ( args )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(112, 31);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Function"), root_1);

					DebugLocation(112, 48);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(112, 51);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:112:51: ( args )?
					if (stream_args.HasNext)
					{
						DebugLocation(112, 51);
						adaptor.AddChild(root_1, stream_args.NextTree());

					}
					stream_args.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyOrFunction", 15);
			LeaveRule("propertyOrFunction", 15);
			LeaveRule_propertyOrFunction();
		}
		DebugLocation(113, 4);
		} finally { DebugExitRule(GrammarFileName, "propertyOrFunction"); }
		return retval;

	}
	// $ANTLR end "propertyOrFunction"

	partial void EnterRule_args();
	partial void LeaveRule_args();

	// $ANTLR start "args"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:115:1: args : logicalExpression ( ',' logicalExpression )* -> ^( TYPE[\"Args\"] ( logicalExpression )* ) ;
	[GrammarRule("args")]
	private AstParserRuleReturnScope<CommonTree, IToken> args()
	{
		EnterRule_args();
		EnterRule("args", 16);
		TraceIn("args", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal63 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression62 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression64 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal63_tree = default(CommonTree);
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleSubtreeStream stream_logicalExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalExpression");
		try { DebugEnterRule(GrammarFileName, "args");
		DebugLocation(115, 91);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:115:7: ( logicalExpression ( ',' logicalExpression )* -> ^( TYPE[\"Args\"] ( logicalExpression )* ) )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:115:11: logicalExpression ( ',' logicalExpression )*
			{
			DebugLocation(115, 11);
			PushFollow(Follow._logicalExpression_in_args769);
			logicalExpression62=logicalExpression();
			PopFollow();

			stream_logicalExpression.Add(logicalExpression62.Tree);
			DebugLocation(115, 29);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:115:29: ( ',' logicalExpression )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==44))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:115:30: ',' logicalExpression
					{
					DebugLocation(115, 30);
					char_literal63=(IToken)Match(input,44,Follow._44_in_args772);  
					stream_44.Add(char_literal63);

					DebugLocation(115, 34);
					PushFollow(Follow._logicalExpression_in_args774);
					logicalExpression64=logicalExpression();
					PopFollow();

					stream_logicalExpression.Add(logicalExpression64.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }



			{
			// AST REWRITE
			// elements: logicalExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 115:55: -> ^( TYPE[\"Args\"] ( logicalExpression )* )
			{
				DebugLocation(115, 58);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:115:58: ^( TYPE[\"Args\"] ( logicalExpression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(115, 60);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Args"), root_1);

				DebugLocation(115, 73);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:115:73: ( logicalExpression )*
				while ( stream_logicalExpression.HasNext )
				{
					DebugLocation(115, 73);
					adaptor.AddChild(root_1, stream_logicalExpression.NextTree());

				}
				stream_logicalExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("args", 16);
			LeaveRule("args", 16);
			LeaveRule_args();
		}
		DebugLocation(115, 91);
		} finally { DebugExitRule(GrammarFileName, "args"); }
		return retval;

	}
	// $ANTLR end "args"

	partial void EnterRule_value();
	partial void LeaveRule_value();

	// $ANTLR start "value"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:144:1: value : ( INT -> ^( TYPE[\"Int\"] INT ) | FLOAT -> ^( TYPE[\"Float\"] FLOAT ) | STRING -> ^( TYPE[\"String\"] STRING ) | BOOLEAN -> ^( TYPE[\"Boolean\"] BOOLEAN ) | DOUBLE -> ^( TYPE[\"Double\"] DOUBLE ) | CHAR -> ^( TYPE[\"Char\"] CHAR ) );
	[GrammarRule("value")]
	private AstParserRuleReturnScope<CommonTree, IToken> value()
	{
		EnterRule_value();
		EnterRule("value", 17);
		TraceIn("value", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT65 = default(IToken);
		IToken FLOAT66 = default(IToken);
		IToken STRING67 = default(IToken);
		IToken BOOLEAN68 = default(IToken);
		IToken DOUBLE69 = default(IToken);
		IToken CHAR70 = default(IToken);

		CommonTree INT65_tree = default(CommonTree);
		CommonTree FLOAT66_tree = default(CommonTree);
		CommonTree STRING67_tree = default(CommonTree);
		CommonTree BOOLEAN68_tree = default(CommonTree);
		CommonTree DOUBLE69_tree = default(CommonTree);
		CommonTree CHAR70_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FLOAT=new RewriteRuleITokenStream(adaptor,"token FLOAT");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		RewriteRuleITokenStream stream_CHAR=new RewriteRuleITokenStream(adaptor,"token CHAR");
		RewriteRuleITokenStream stream_DOUBLE=new RewriteRuleITokenStream(adaptor,"token DOUBLE");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_BOOLEAN=new RewriteRuleITokenStream(adaptor,"token BOOLEAN");
		try { DebugEnterRule(GrammarFileName, "value");
		DebugLocation(144, 4);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:144:10: ( INT -> ^( TYPE[\"Int\"] INT ) | FLOAT -> ^( TYPE[\"Float\"] FLOAT ) | STRING -> ^( TYPE[\"String\"] STRING ) | BOOLEAN -> ^( TYPE[\"Boolean\"] BOOLEAN ) | DOUBLE -> ^( TYPE[\"Double\"] DOUBLE ) | CHAR -> ^( TYPE[\"Char\"] CHAR ) )
			int alt21=6;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt21 = 1;
				}
				break;
			case FLOAT:
				{
				alt21 = 2;
				}
				break;
			case STRING:
				{
				alt21 = 3;
				}
				break;
			case BOOLEAN:
				{
				alt21 = 4;
				}
				break;
			case DOUBLE:
				{
				alt21 = 5;
				}
				break;
			case CHAR:
				{
				alt21 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:145:4: INT
				{
				DebugLocation(145, 4);
				INT65=(IToken)Match(input,INT,Follow._INT_in_value826);  
				stream_INT.Add(INT65);



				{
				// AST REWRITE
				// elements: INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 145:8: -> ^( TYPE[\"Int\"] INT )
				{
					DebugLocation(145, 11);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:145:11: ^( TYPE[\"Int\"] INT )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(145, 13);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Int"), root_1);

					DebugLocation(145, 25);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:146:10: FLOAT
				{
				DebugLocation(146, 10);
				FLOAT66=(IToken)Match(input,FLOAT,Follow._FLOAT_in_value847);  
				stream_FLOAT.Add(FLOAT66);



				{
				// AST REWRITE
				// elements: FLOAT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 146:16: -> ^( TYPE[\"Float\"] FLOAT )
				{
					DebugLocation(146, 19);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:146:19: ^( TYPE[\"Float\"] FLOAT )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(146, 21);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Float"), root_1);

					DebugLocation(146, 35);
					adaptor.AddChild(root_1, stream_FLOAT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:147:10: STRING
				{
				DebugLocation(147, 10);
				STRING67=(IToken)Match(input,STRING,Follow._STRING_in_value868);  
				stream_STRING.Add(STRING67);



				{
				// AST REWRITE
				// elements: STRING
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 147:17: -> ^( TYPE[\"String\"] STRING )
				{
					DebugLocation(147, 20);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:147:20: ^( TYPE[\"String\"] STRING )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(147, 22);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "String"), root_1);

					DebugLocation(147, 37);
					adaptor.AddChild(root_1, stream_STRING.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:148:10: BOOLEAN
				{
				DebugLocation(148, 10);
				BOOLEAN68=(IToken)Match(input,BOOLEAN,Follow._BOOLEAN_in_value889);  
				stream_BOOLEAN.Add(BOOLEAN68);



				{
				// AST REWRITE
				// elements: BOOLEAN
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 148:19: -> ^( TYPE[\"Boolean\"] BOOLEAN )
				{
					DebugLocation(148, 22);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:148:22: ^( TYPE[\"Boolean\"] BOOLEAN )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(148, 24);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Boolean"), root_1);

					DebugLocation(148, 40);
					adaptor.AddChild(root_1, stream_BOOLEAN.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:149:8: DOUBLE
				{
				DebugLocation(149, 8);
				DOUBLE69=(IToken)Match(input,DOUBLE,Follow._DOUBLE_in_value909);  
				stream_DOUBLE.Add(DOUBLE69);



				{
				// AST REWRITE
				// elements: DOUBLE
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 149:16: -> ^( TYPE[\"Double\"] DOUBLE )
				{
					DebugLocation(149, 19);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:149:19: ^( TYPE[\"Double\"] DOUBLE )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(149, 21);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Double"), root_1);

					DebugLocation(149, 36);
					adaptor.AddChild(root_1, stream_DOUBLE.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:150:8: CHAR
				{
				DebugLocation(150, 8);
				CHAR70=(IToken)Match(input,CHAR,Follow._CHAR_in_value929);  
				stream_CHAR.Add(CHAR70);



				{
				// AST REWRITE
				// elements: CHAR
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 150:14: -> ^( TYPE[\"Char\"] CHAR )
				{
					DebugLocation(150, 17);
					// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:150:17: ^( TYPE[\"Char\"] CHAR )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(150, 19);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Char"), root_1);

					DebugLocation(150, 32);
					adaptor.AddChild(root_1, stream_CHAR.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value", 17);
			LeaveRule("value", 17);
			LeaveRule_value();
		}
		DebugLocation(151, 4);
		} finally { DebugExitRule(GrammarFileName, "value"); }
		return retval;

	}
	// $ANTLR end "value"

	partial void EnterRule_attribute();
	partial void LeaveRule_attribute();

	// $ANTLR start "attribute"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:161:1: attribute : '@' ID ( CHECK )? -> ^( TYPE[\"Attribute\"] ID ( CHECK )? ) ;
	[GrammarRule("attribute")]
	private AstParserRuleReturnScope<CommonTree, IToken> attribute()
	{
		EnterRule_attribute();
		EnterRule("attribute", 18);
		TraceIn("attribute", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal71 = default(IToken);
		IToken ID72 = default(IToken);
		IToken CHECK73 = default(IToken);

		CommonTree char_literal71_tree = default(CommonTree);
		CommonTree ID72_tree = default(CommonTree);
		CommonTree CHECK73_tree = default(CommonTree);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_CHECK=new RewriteRuleITokenStream(adaptor,"token CHECK");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "attribute");
		DebugLocation(161, 51);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:162:2: ( '@' ID ( CHECK )? -> ^( TYPE[\"Attribute\"] ID ( CHECK )? ) )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:162:5: '@' ID ( CHECK )?
			{
			DebugLocation(162, 5);
			char_literal71=(IToken)Match(input,45,Follow._45_in_attribute965);  
			stream_45.Add(char_literal71);

			DebugLocation(162, 9);
			ID72=(IToken)Match(input,ID,Follow._ID_in_attribute967);  
			stream_ID.Add(ID72);

			DebugLocation(162, 12);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:162:12: ( CHECK )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if ((LA22_0==CHECK))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:162:12: CHECK
				{
				DebugLocation(162, 12);
				CHECK73=(IToken)Match(input,CHECK,Follow._CHECK_in_attribute969);  
				stream_CHECK.Add(CHECK73);


				}
				break;

			}
			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: CHECK, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 162:19: -> ^( TYPE[\"Attribute\"] ID ( CHECK )? )
			{
				DebugLocation(162, 22);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:162:22: ^( TYPE[\"Attribute\"] ID ( CHECK )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(162, 24);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Attribute"), root_1);

				DebugLocation(162, 42);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(162, 45);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:162:45: ( CHECK )?
				if (stream_CHECK.HasNext)
				{
					DebugLocation(162, 45);
					adaptor.AddChild(root_1, stream_CHECK.NextNode());

				}
				stream_CHECK.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attribute", 18);
			LeaveRule("attribute", 18);
			LeaveRule_attribute();
		}
		DebugLocation(162, 51);
		} finally { DebugExitRule(GrammarFileName, "attribute"); }
		return retval;

	}
	// $ANTLR end "attribute"

	partial void EnterRule_internalattribute();
	partial void LeaveRule_internalattribute();

	// $ANTLR start "internalattribute"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:164:1: internalattribute : '@@' ID ( CHECK )? -> ^( TYPE[\"InternalAttribute\"] ID ( CHECK )? ) ;
	[GrammarRule("internalattribute")]
	private AstParserRuleReturnScope<CommonTree, IToken> internalattribute()
	{
		EnterRule_internalattribute();
		EnterRule("internalattribute", 19);
		TraceIn("internalattribute", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal74 = default(IToken);
		IToken ID75 = default(IToken);
		IToken CHECK76 = default(IToken);

		CommonTree string_literal74_tree = default(CommonTree);
		CommonTree ID75_tree = default(CommonTree);
		CommonTree CHECK76_tree = default(CommonTree);
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleITokenStream stream_CHECK=new RewriteRuleITokenStream(adaptor,"token CHECK");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "internalattribute");
		DebugLocation(164, 60);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:165:2: ( '@@' ID ( CHECK )? -> ^( TYPE[\"InternalAttribute\"] ID ( CHECK )? ) )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:165:5: '@@' ID ( CHECK )?
			{
			DebugLocation(165, 5);
			string_literal74=(IToken)Match(input,46,Follow._46_in_internalattribute994);  
			stream_46.Add(string_literal74);

			DebugLocation(165, 10);
			ID75=(IToken)Match(input,ID,Follow._ID_in_internalattribute996);  
			stream_ID.Add(ID75);

			DebugLocation(165, 13);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:165:13: ( CHECK )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_0 = input.LA(1);

			if ((LA23_0==CHECK))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:165:13: CHECK
				{
				DebugLocation(165, 13);
				CHECK76=(IToken)Match(input,CHECK,Follow._CHECK_in_internalattribute998);  
				stream_CHECK.Add(CHECK76);


				}
				break;

			}
			} finally { DebugExitSubRule(23); }



			{
			// AST REWRITE
			// elements: CHECK, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 165:20: -> ^( TYPE[\"InternalAttribute\"] ID ( CHECK )? )
			{
				DebugLocation(165, 23);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:165:23: ^( TYPE[\"InternalAttribute\"] ID ( CHECK )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(165, 25);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "InternalAttribute"), root_1);

				DebugLocation(165, 51);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(165, 54);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:165:54: ( CHECK )?
				if (stream_CHECK.HasNext)
				{
					DebugLocation(165, 54);
					adaptor.AddChild(root_1, stream_CHECK.NextNode());

				}
				stream_CHECK.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("internalattribute", 19);
			LeaveRule("internalattribute", 19);
			LeaveRule_internalattribute();
		}
		DebugLocation(165, 60);
		} finally { DebugExitRule(GrammarFileName, "internalattribute"); }
		return retval;

	}
	// $ANTLR end "internalattribute"

	partial void EnterRule_parameter();
	partial void LeaveRule_parameter();

	// $ANTLR start "parameter"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:173:1: parameter : ID -> ^( TYPE[\"Parameter\"] ID ) ;
	[GrammarRule("parameter")]
	private AstParserRuleReturnScope<CommonTree, IToken> parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 20);
		TraceIn("parameter", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID77 = default(IToken);

		CommonTree ID77_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(173, 33);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:174:2: ( ID -> ^( TYPE[\"Parameter\"] ID ) )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:174:5: ID
			{
			DebugLocation(174, 5);
			ID77=(IToken)Match(input,ID,Follow._ID_in_parameter1031);  
			stream_ID.Add(ID77);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 174:8: -> ^( TYPE[\"Parameter\"] ID )
			{
				DebugLocation(174, 11);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:174:11: ^( TYPE[\"Parameter\"] ID )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(174, 13);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "Parameter"), root_1);

				DebugLocation(174, 31);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter", 20);
			LeaveRule("parameter", 20);
			LeaveRule_parameter();
		}
		DebugLocation(174, 33);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return retval;

	}
	// $ANTLR end "parameter"

	partial void EnterRule_specialData();
	partial void LeaveRule_specialData();

	// $ANTLR start "specialData"
	// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:176:1: specialData : '$' ID '[' logicalExpression ']' -> ^( TYPE[\"SpecialData\"] ID logicalExpression ) ;
	[GrammarRule("specialData")]
	private AstParserRuleReturnScope<CommonTree, IToken> specialData()
	{
		EnterRule_specialData();
		EnterRule("specialData", 21);
		TraceIn("specialData", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal78 = default(IToken);
		IToken ID79 = default(IToken);
		IToken char_literal80 = default(IToken);
		IToken char_literal82 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalExpression81 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal78_tree = default(CommonTree);
		CommonTree ID79_tree = default(CommonTree);
		CommonTree char_literal80_tree = default(CommonTree);
		CommonTree char_literal82_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SQBRACKETCLOSE=new RewriteRuleITokenStream(adaptor,"token SQBRACKETCLOSE");
		RewriteRuleITokenStream stream_SQBRACKETOPEN=new RewriteRuleITokenStream(adaptor,"token SQBRACKETOPEN");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleSubtreeStream stream_logicalExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalExpression");
		try { DebugEnterRule(GrammarFileName, "specialData");
		DebugLocation(176, 82);
		try
		{
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:177:2: ( '$' ID '[' logicalExpression ']' -> ^( TYPE[\"SpecialData\"] ID logicalExpression ) )
			DebugEnterAlt(1);
			// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:177:4: '$' ID '[' logicalExpression ']'
			{
			DebugLocation(177, 4);
			char_literal78=(IToken)Match(input,41,Follow._41_in_specialData1051);  
			stream_41.Add(char_literal78);

			DebugLocation(177, 8);
			ID79=(IToken)Match(input,ID,Follow._ID_in_specialData1053);  
			stream_ID.Add(ID79);

			DebugLocation(177, 11);
			char_literal80=(IToken)Match(input,SQBRACKETOPEN,Follow._SQBRACKETOPEN_in_specialData1055);  
			stream_SQBRACKETOPEN.Add(char_literal80);

			DebugLocation(177, 15);
			PushFollow(Follow._logicalExpression_in_specialData1057);
			logicalExpression81=logicalExpression();
			PopFollow();

			stream_logicalExpression.Add(logicalExpression81.Tree);
			DebugLocation(177, 33);
			char_literal82=(IToken)Match(input,SQBRACKETCLOSE,Follow._SQBRACKETCLOSE_in_specialData1059);  
			stream_SQBRACKETCLOSE.Add(char_literal82);



			{
			// AST REWRITE
			// elements: logicalExpression, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 177:37: -> ^( TYPE[\"SpecialData\"] ID logicalExpression )
			{
				DebugLocation(177, 40);
				// E:\\My .NET Projects\\Sceelix\\Source\\Sceelix.Designer.Graphs\\ExpressionParsing\\SceelixGrammar.g:177:40: ^( TYPE[\"SpecialData\"] ID logicalExpression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(177, 42);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE, "SpecialData"), root_1);

				DebugLocation(177, 62);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(177, 65);
				adaptor.AddChild(root_1, stream_logicalExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("specialData", 21);
			LeaveRule("specialData", 21);
			LeaveRule_specialData();
		}
		DebugLocation(177, 82);
		} finally { DebugExitRule(GrammarFileName, "specialData"); }
		return retval;

	}
	// $ANTLR end "specialData"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _logicalExpression_in_expr85 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_expr87 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanAndExpression_in_logicalExpression107 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _OR_in_logicalExpression111 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _booleanAndExpression_in_logicalExpression114 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _equalityExpression_in_booleanAndExpression141 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _AND_in_booleanAndExpression145 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _equalityExpression_in_booleanAndExpression148 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression175 = new BitSet(new ulong[]{0x40004002UL});
		public static readonly BitSet _EQUALS_in_equalityExpression187 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _NOTEQUALS_in_equalityExpression199 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression203 = new BitSet(new ulong[]{0x40004002UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression229 = new BitSet(new ulong[]{0x30C0002UL});
		public static readonly BitSet _LT_in_relationalExpression234 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _LTEQ_in_relationalExpression248 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _GT_in_relationalExpression262 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _GTEQ_in_relationalExpression276 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _additiveExpression_in_relationalExpression280 = new BitSet(new ulong[]{0x30C0002UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression302 = new BitSet(new ulong[]{0x204000002UL});
		public static readonly BitSet _PLUS_in_additiveExpression314 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _MINUS_in_additiveExpression326 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression338 = new BitSet(new ulong[]{0x204000002UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression361 = new BitSet(new ulong[]{0x18000802UL});
		public static readonly BitSet _MULT_in_multiplicativeExpression366 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _DIV_in_multiplicativeExpression371 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _MOD_in_multiplicativeExpression376 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression381 = new BitSet(new ulong[]{0x18000802UL});
		public static readonly BitSet _NOT_in_unaryExpression404 = new BitSet(new ulong[]{0x6430006220C0UL});
		public static readonly BitSet _MINUS_in_unaryExpression407 = new BitSet(new ulong[]{0x6430006220C0UL});
		public static readonly BitSet _arrayExpression_in_unaryExpression412 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_arrayExpression426 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _SQBRACKETOPEN_in_arrayExpression429 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _logicalExpression_in_arrayExpression432 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SQBRACKETCLOSE_in_arrayExpression434 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _42_in_primaryExpression460 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _logicalExpression_in_primaryExpression462 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_primaryExpression464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _value_in_primaryExpression483 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_primaryExpression495 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_in_primaryExpression505 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _internalattribute_in_primaryExpression513 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primaryExpression528 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_primaryExpression531 = new BitSet(new ulong[]{0x6C30246220C0UL});
		public static readonly BitSet _args_in_primaryExpression533 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_primaryExpression536 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_in_primaryExpression559 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SQBRACKETOPEN_in_array582 = new BitSet(new ulong[]{0x6438246220C0UL});
		public static readonly BitSet _arraykeyValues_in_array584 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SQBRACKETCLOSE_in_array587 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _keyvalue_in_arraykeyValues609 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _44_in_arraykeyValues612 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _keyvalue_in_arraykeyValues614 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _logicalExpression_in_keyvalue639 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COLON_in_keyvalue642 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _logicalExpression_in_keyvalue645 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_className688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_propertyOrFunction707 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_propertyOrFunction728 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_propertyOrFunction731 = new BitSet(new ulong[]{0x6C30246220C0UL});
		public static readonly BitSet _args_in_propertyOrFunction733 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_propertyOrFunction736 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalExpression_in_args769 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _44_in_args772 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _logicalExpression_in_args774 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _INT_in_value826 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_value847 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_value868 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOLEAN_in_value889 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOUBLE_in_value909 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_in_value929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _45_in_attribute965 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_attribute967 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _CHECK_in_attribute969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _46_in_internalattribute994 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_internalattribute996 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _CHECK_in_internalattribute998 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_parameter1031 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_specialData1051 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_specialData1053 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _SQBRACKETOPEN_in_specialData1055 = new BitSet(new ulong[]{0x6430246220C0UL});
		public static readonly BitSet _logicalExpression_in_specialData1057 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SQBRACKETCLOSE_in_specialData1059 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Sceelix.Designer.Graphs.ExpressionParsing
